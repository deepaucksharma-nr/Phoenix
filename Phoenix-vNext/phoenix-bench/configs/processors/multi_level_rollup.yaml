# Multi-level "others" rollup with drill-down capability
# This processor configuration can be added to the otelcol-main.yaml file

  # Primary level rollup - Groups less important processes by owner
  groupbyattrs/multilevel_primary:
    keys: [host.name, service.name, process.owner]
    aggregation_type: sum
    grouping:
      # Group processes that aren't in top performers or critical apps
      match_keys:
        - process.priority: "low"
        - process.category: "background"
      output_group_name: phoenix.others.low
      group_by_min_count: 3
      group_by_max_count: 15
      group_by_min_percent: 0.1
      disable_if_match_keys_not_found: false

  # Secondary level rollup - Creates sub-groups within the primary rollup
  # This breaks down "others" into more meaningful categories
  transform/multilevel_secondary:
    metric_statements:
      - context: metric
        statements:
          # Only operate on metrics with the phoenix.others.low prefix
          - set(is_others, HasPrefix(name, "phoenix.others.low"))
          - continue() where !is_others
          
          # Get process type from command line or owner
          - set(process_type, "unknown")
          - set(process_type, ConditionalMatch(attributes["process.command_line"] == nil, "unknown", "extracted_from_cmd"))
          # In a real implementation, we would extract meaningful types from command line
          # For simulation, we'll use these placeholder categories:
          - set(process_type, "system") where HasPrefix(attributes["process.owner"], "system")
          - set(process_type, "daemon") where HasPrefix(attributes["process.owner"], "daemon")
          - set(process_type, "user") where HasPrefix(attributes["process.owner"], "user")
          
          # Create a new name with the process type as a suffix
          - set(name, Concat(name, ".", process_type))

  # Tertiary level rollup - For user processes, add an application domain suffix
  transform/multilevel_tertiary:
    metric_statements:
      - context: metric
        statements:
          # Only operate on metrics with the phoenix.others.low.user prefix
          - set(is_user_others, HasPrefix(name, "phoenix.others.low.user"))
          - continue() where !is_user_others
          
          # Get application domain from executable name
          - set(app_domain, "misc")
          # In a real implementation, we would classify by actual app domain
          # For simulation, we'll use these placeholder categories:
          - set(app_domain, "browser") where HasPrefix(attributes["process.executable.name"], "firefox") || HasPrefix(attributes["process.executable.name"], "chrome")
          - set(app_domain, "office") where HasPrefix(attributes["process.executable.name"], "libre") || HasPrefix(attributes["process.executable.name"], "office")
          - set(app_domain, "media") where HasPrefix(attributes["process.executable.name"], "vlc") || HasPrefix(attributes["process.executable.name"], "mpv")
          
          # Create a new name with the application domain as a suffix
          - set(name, Concat(name, ".", app_domain))

  # Filter to enhance rollup with metadata
  metricstransform/multi_level_metrics:
    transforms:
      # Add properties to all multilevel metrics to help with filtering and grouping
      - include: "phoenix\\.others\\..*"
        match_type: regexp
        action: update
        operations:
          - action: add_label
            new_label: phoenix_rollup
            new_value: "true"
          - action: add_label
            new_label: rollup_level
            new_value: "1"
            
      - include: "phoenix\\.others\\.low\\..*"
        match_type: regexp
        action: update
        operations:
          - action: update_label
            label: rollup_level
            new_value: "2"
            
      - include: "phoenix\\.others\\.low\\.user\\..*"
        match_type: regexp
        action: update
        operations:
          - action: update_label
            label: rollup_level
            new_value: "3"
            
      # Add sampling info for the user to understand data completeness
      - include: "phoenix\\.others\\..*"
        match_type: regexp
        action: update
        operations:
          - action: add_label
            new_label: sample_size
            new_value: "100%" # Percentage of original metrics represented
          - action: add_label
            new_label: group_count
            new_value: "varies" # Number of original metrics grouped together

  # Example usage in a specialized pipeline for multi-level rollup
  # metrics/multilevel_others:
  #   receivers: [replicate/fanout_to_main_pipelines]
  #   processors:
  #     - resource/pipeline_selector_opt
  #     - filter/drop_noise_moderate
  #     - groupbyattrs/multilevel_primary
  #     - transform/multilevel_secondary
  #     - transform/multilevel_tertiary
  #     - metricstransform/multi_level_metrics
  #     - transform/preserve_entity
  #     - batch
  #   exporters: [otlphttp/opt, prometheusremotewrite/local]