package api

import (
	"context"
	"encoding/json"
	"net/http"
	"sync"
	"time"

	"github.com/gorilla/websocket"
	"go.uber.org/zap"
	
	"github.com/phoenix/platform/pkg/interfaces"
)

var upgrader = websocket.Upgrader{
	CheckOrigin: func(r *http.Request) bool {
		// Allow connections from any origin in development
		// TODO: Restrict in production
		return true
	},
}

// WebSocketHandler handles WebSocket connections
type WebSocketHandler struct {
	logger       *zap.Logger
	eventBus     interfaces.EventBus
	clients      map[string]*WebSocketClient
	clientsMutex sync.RWMutex
	broadcast    chan *WebSocketMessage
}

// WebSocketClient represents a connected client
type WebSocketClient struct {
	ID         string
	UserID     string
	conn       *websocket.Conn
	send       chan *WebSocketMessage
	handler    *WebSocketHandler
	subscribed map[string]bool
}

// WebSocketMessage represents a message sent over WebSocket
type WebSocketMessage struct {
	Type      string          `json:"type"`
	Event     string          `json:"event,omitempty"`
	Payload   json.RawMessage `json:"payload"`
	Timestamp time.Time       `json:"timestamp"`
}

// NewWebSocketHandler creates a new WebSocket handler
func NewWebSocketHandler(logger *zap.Logger, eventBus interfaces.EventBus) *WebSocketHandler {
	handler := &WebSocketHandler{
		logger:    logger,
		eventBus:  eventBus,
		clients:   make(map[string]*WebSocketClient),
		broadcast: make(chan *WebSocketMessage, 256),
	}

	// Subscribe to events from the event bus
	if eventBus != nil {
		eventBus.Subscribe("experiment.*", handler.handleExperimentEvent)
		eventBus.Subscribe("metrics.*", handler.handleMetricsEvent)
		eventBus.Subscribe("system.*", handler.handleSystemEvent)
	}

	// Start broadcast goroutine
	go handler.runBroadcast()

	return handler
}

// ServeHTTP handles WebSocket upgrade and connections
func (h *WebSocketHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	// Extract user ID from authentication (simplified for now)
	userID := r.Header.Get("X-User-ID")
	if userID == "" {
		userID = "anonymous"
	}

	// Upgrade HTTP connection to WebSocket
	conn, err := upgrader.Upgrade(w, r, nil)
	if err != nil {
		h.logger.Error("failed to upgrade connection", zap.Error(err))
		return
	}

	// Create new client
	client := &WebSocketClient{
		ID:         generateClientID(),
		UserID:     userID,
		conn:       conn,
		send:       make(chan *WebSocketMessage, 256),
		handler:    h,
		subscribed: make(map[string]bool),
	}

	// Register client
	h.registerClient(client)

	// Start client goroutines
	go client.writePump()
	go client.readPump()

	h.logger.Info("WebSocket client connected",
		zap.String("clientID", client.ID),
		zap.String("userID", client.UserID))
}

// registerClient adds a new client
func (h *WebSocketHandler) registerClient(client *WebSocketClient) {
	h.clientsMutex.Lock()
	defer h.clientsMutex.Unlock()
	h.clients[client.ID] = client
}

// unregisterClient removes a client
func (h *WebSocketHandler) unregisterClient(client *WebSocketClient) {
	h.clientsMutex.Lock()
	defer h.clientsMutex.Unlock()
	if _, ok := h.clients[client.ID]; ok {
		delete(h.clients, client.ID)
		close(client.send)
	}
}

// runBroadcast handles broadcasting messages to all clients
func (h *WebSocketHandler) runBroadcast() {
	for {
		select {
		case message := <-h.broadcast:
			h.clientsMutex.RLock()
			for _, client := range h.clients {
				select {
				case client.send <- message:
				default:
					// Client's send channel is full, close it
					h.logger.Warn("client send channel full, closing",
						zap.String("clientID", client.ID))
					close(client.send)
					delete(h.clients, client.ID)
				}
			}
			h.clientsMutex.RUnlock()
		}
	}
}

// sendToUser sends a message to all clients of a specific user
func (h *WebSocketHandler) sendToUser(userID string, message *WebSocketMessage) {
	h.clientsMutex.RLock()
	defer h.clientsMutex.RUnlock()

	for _, client := range h.clients {
		if client.UserID == userID {
			select {
			case client.send <- message:
			default:
				// Client's send channel is full
				h.logger.Warn("client send channel full",
					zap.String("clientID", client.ID))
			}
		}
	}
}

// sendToSubscribers sends a message to clients subscribed to a specific event
func (h *WebSocketHandler) sendToSubscribers(event string, message *WebSocketMessage) {
	h.clientsMutex.RLock()
	defer h.clientsMutex.RUnlock()

	for _, client := range h.clients {
		if client.subscribed[event] {
			select {
			case client.send <- message:
			default:
				h.logger.Warn("client send channel full",
					zap.String("clientID", client.ID))
			}
		}
	}
}

// Event handlers

func (h *WebSocketHandler) handleExperimentEvent(event interfaces.Event) {
	// Convert event to WebSocket message
	payload, err := json.Marshal(event.Data)
	if err != nil {
		h.logger.Error("failed to marshal event data", zap.Error(err))
		return
	}

	message := &WebSocketMessage{
		Type:      "experiment.update",
		Event:     event.Type,
		Payload:   payload,
		Timestamp: event.Timestamp,
	}

	// Send to subscribers
	h.sendToSubscribers(event.Type, message)
}

func (h *WebSocketHandler) handleMetricsEvent(event interfaces.Event) {
	payload, err := json.Marshal(event.Data)
	if err != nil {
		h.logger.Error("failed to marshal event data", zap.Error(err))
		return
	}

	message := &WebSocketMessage{
		Type:      "metrics.update",
		Event:     event.Type,
		Payload:   payload,
		Timestamp: event.Timestamp,
	}

	h.sendToSubscribers(event.Type, message)
}

func (h *WebSocketHandler) handleSystemEvent(event interfaces.Event) {
	payload, err := json.Marshal(event.Data)
	if err != nil {
		h.logger.Error("failed to marshal event data", zap.Error(err))
		return
	}

	messageType := "notification"
	if event.Type == "system.alert" {
		messageType = "alert"
	}

	message := &WebSocketMessage{
		Type:      messageType,
		Event:     event.Type,
		Payload:   payload,
		Timestamp: event.Timestamp,
	}

	// Broadcast system events to all clients
	h.broadcast <- message
}

// Client methods

// readPump handles incoming messages from the client
func (c *WebSocketClient) readPump() {
	defer func() {
		c.handler.unregisterClient(c)
		c.conn.Close()
	}()

	c.conn.SetReadDeadline(time.Now().Add(60 * time.Second))
	c.conn.SetPongHandler(func(string) error {
		c.conn.SetReadDeadline(time.Now().Add(60 * time.Second))
		return nil
	})

	for {
		var message WebSocketMessage
		err := c.conn.ReadJSON(&message)
		if err != nil {
			if websocket.IsUnexpectedCloseError(err, websocket.CloseGoingAway, websocket.CloseAbnormalClosure) {
				c.handler.logger.Error("websocket error", zap.Error(err))
			}
			break
		}

		// Handle incoming message
		c.handleMessage(&message)
	}
}

// writePump handles sending messages to the client
func (c *WebSocketClient) writePump() {
	ticker := time.NewTicker(54 * time.Second)
	defer func() {
		ticker.Stop()
		c.conn.Close()
	}()

	for {
		select {
		case message, ok := <-c.send:
			c.conn.SetWriteDeadline(time.Now().Add(10 * time.Second))
			if !ok {
				c.conn.WriteMessage(websocket.CloseMessage, []byte{})
				return
			}

			if err := c.conn.WriteJSON(message); err != nil {
				return
			}

		case <-ticker.C:
			c.conn.SetWriteDeadline(time.Now().Add(10 * time.Second))
			if err := c.conn.WriteMessage(websocket.PingMessage, nil); err != nil {
				return
			}
		}
	}
}

// handleMessage processes incoming messages from the client
func (c *WebSocketClient) handleMessage(message *WebSocketMessage) {
	switch message.Type {
	case "subscribe":
		// Subscribe to an event
		var payload struct {
			Event string `json:"event"`
		}
		if err := json.Unmarshal(message.Payload, &payload); err == nil {
			c.subscribed[payload.Event] = true
			c.handler.logger.Info("client subscribed to event",
				zap.String("clientID", c.ID),
				zap.String("event", payload.Event))
		}

	case "unsubscribe":
		// Unsubscribe from an event
		var payload struct {
			Event string `json:"event"`
		}
		if err := json.Unmarshal(message.Payload, &payload); err == nil {
			delete(c.subscribed, payload.Event)
			c.handler.logger.Info("client unsubscribed from event",
				zap.String("clientID", c.ID),
				zap.String("event", payload.Event))
		}

	case "ping":
		// Respond with pong
		response := &WebSocketMessage{
			Type:      "pong",
			Timestamp: time.Now(),
		}
		select {
		case c.send <- response:
		default:
		}

	default:
		c.handler.logger.Warn("unknown message type",
			zap.String("type", message.Type))
	}
}

// generateClientID generates a unique client ID
func generateClientID() string {
	return "ws-" + time.Now().Format("20060102150405") + "-" + randomString(8)
}

// randomString generates a random string of the given length
func randomString(length int) string {
	const charset = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
	b := make([]byte, length)
	for i := range b {
		b[i] = charset[time.Now().UnixNano()%int64(len(charset))]
	}
	return string(b)
}